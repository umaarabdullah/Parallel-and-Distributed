/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "matrixOp.h"

Matrix *
matrix_add_1_svc(MatrixPair *argp, struct svc_req *rqstp)
{
	static Matrix result;

	if (argp == NULL) {
        fprintf(stderr, "matrix_add_1_svc: Invalid input\n");
        return NULL;
    }

	int rows, cols, totalElements;
	
	rows = argp->matrix1.rows;
    cols = argp->matrix1.cols;
	totalElements = rows * cols;
	
	rows = argp->matrix2.rows;
    cols = argp->matrix2.cols;
	totalElements = rows * cols;

	// for (int i = 0; i < argp->matrix1.rows; i++) {
	// 	for (int j = 0; j < argp->matrix1.cols; j++) {
	// 		printf("%d ", argp->matrix1.data[i * argp->matrix1.cols + j]);
	// 	}
	// 	printf("\n");
	// }
	// for (int i = 0; i < argp->matrix2.rows; i++) {
	// 	for (int j = 0; j < argp->matrix2.cols; j++) {
	// 		printf("%d ", argp->matrix2.data[i * argp->matrix2.cols + j]);
	// 	}
	// 	printf("\n");
	// }

	result.rows = rows;
	result.cols = cols;

    /* Check if the matrices have the same dimensions */
    if (argp->matrix1.rows != argp->matrix2.rows || argp->matrix1.cols != argp->matrix2.cols) {
        fprintf(stderr, "matrix_add_1_svc: Matrices must have the same dimensions for addition\n");
        return NULL;
    }

    /* Perform matrix addition */
	int i, j;
    for (i = 0; i < argp->matrix1.rows; i++) {
        for (j = 0; j < argp->matrix1.cols; j++) {
            result.data[i*result.cols + j] = argp->matrix1.data[i*argp->matrix1.cols + j] +
                                             argp->matrix2.data[i*argp->matrix2.cols + j];
        }
    }

	return &result;
}

Matrix *
matrix_mul_1_svc(MatrixPair *argp, struct svc_req *rqstp)
{
	static Matrix result;

	// Check matrix dimensions for multiplication
    if (argp->matrix1.cols != argp->matrix2.rows) {
        fprintf(stderr, "Invalid matrix dimensions for multiplication\n");
        return NULL;
    }

	result.rows = argp->matrix1.rows;
    result.cols = argp->matrix2.cols;

    for (int i = 0; i < argp->matrix1.rows; i++) {
        for (int j = 0; j < argp->matrix2.cols; j++) {
            result.data[i*result.cols + j] = 0;
            for (int k = 0; k < argp->matrix1.cols; k++) {
                result.data[i*result.cols + j] +=
                    argp->matrix1.data[i*argp->matrix1.cols + k] *
                    argp->matrix2.data[k*argp->matrix2.cols + j];
            }
        }
    }

	return &result;
}

Matrix *
matrix_inverse_1_svc(Matrix *argp, struct svc_req *rqstp)
{
	static Matrix result;

	// Check if the matrix is square
    if (argp->rows != argp->cols) {
        fprintf(stderr, "Matrix is not square, cannot be inverted\n");
        return NULL;
    }

	
	

	return &result;
}

Matrix *
matrix_transpose_1_svc(Matrix *argp, struct svc_req *rqstp)
{
	static Matrix result;

	/*
	 * insert server code here
	*/

	return &result;
}
